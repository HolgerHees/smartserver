#!/usr/bin/python3

from flask import Flask, request, make_response
import logging

import glob

import signal

import threading
import os
import time

import json

from config import config

from smartserver.server import Server
from smartserver.github import GitHub

from lib import helper
from lib import status
from lib import service
from lib import job
from lib import git
from lib import log

repository_owner = GitHub.getRepositoryOwner(config.repository_url)

watched_data_files = [
    config.status_file
]


class Handler(Server):
    def __init__(self, logger):
        self.logger = logger
        
        log.setLogger(self.logger)

        super().__init__(self.logger, "ci_service")
        
        self.terminated = False
        
        self.state = status.getState(config.status_file)
        self.job_is_running = self._isJobRunning()
        
        self.initWatchedFiles( watched_data_files )
        
        self.loop_event = threading.Event()

        thread = threading.Thread(target=self._jobWatcher, args=())
        thread.start()
        
    def terminate(self):
        self.terminated = True
        self.loop_event.set()
        super().terminate()

    def _isJobRunning(self):
        return service.getPid() is not None
      
    def _jobWatcher(self):
        self._cleanJobs()

        while not self.terminated:
            if self.hasFileChanged(config.status_file):
                self.state = status.getState(config.status_file)
                self.confirmFileChanged(config.status_file)
                self.job_is_running = True
            else:
                job_is_running = self._isJobRunning()
                if self.job_is_running != job_is_running:
                    if not job_is_running and self.state["status"] == "running":
                        self.logger.error("Job crash detected. Marked as 'crashed' now and check log files.")
                        status.setState(config.status_file,u"crashed")
                        
                        self._cleanJobs()

                    self.job_is_running = job_is_running
            
            self.loop_event.wait( 15 if self.job_is_running else 60 )
      
    def _cleanJobs(self):
        running_jobs = glob.glob(u"{}*-*-running-*-*.log".format(config.log_dir))
        if len(running_jobs) > 0:
            cleaned_running_jobs = []
            
            # collect git hashes and logfiles
            git_hashes = {}
            for name in running_jobs:
                details = job.getLogFileDetails(name)
                if self.job_is_running and self.state is not None:
                    if details["config"] == self.state["config"] and details["deployment"] == self.state["deployment"] and details["git_hash"] == self.state["git_hash"]:
                        continue
                      
                cleaned_running_jobs.append(name)
                if details["git_hash"] not in git_hashes:
                    git_hashes[details["git_hash"]] = []
                    
                git_hashes[details["git_hash"]].append(details["deployment"])
                            
            if config.access_token != "" and self.state is not None:
                # process git hashes
                for git_hash in git_hashes: 
                    self.logger.info("Clean states of git hash '{}'".format(git_hash))
                    GitHub.setState(repository_owner,config.access_token,git_hash,"error", self.state["deployment"],"Build crashed")
                    GitHub.cancelPendingStates(repository_owner, config.access_token, self.state["git_hash"], "Build skipped")

            # process logfiles
            for name in cleaned_running_jobs:
                self.logger.info("Clean file '{}'".format(name))
                os.rename(name, name.replace("-running-","-crashed-"))
            
            if service.getPid() is not None:
                service.cleanRunningJobs("all")
          
    def getState(self):
        return json.dumps({ 
            "status": 0,
            "job_is_running": self.job_is_running
        })
      
app = Flask(__name__)

@app.route('/state/', methods = ['POST'])
def state():     
    return handler.getState()
  
#def cleanup(signum, frame):
#    print("Shutdown daemon", flush=True)
#    handler.terminate()
#    exit(0)

#signal.signal(signal.SIGTERM, cleanup)
#signal.signal(signal.SIGINT, cleanup)

if __name__ == '__main__':
    app.logger.setLevel(logging.DEBUG)
    handler = Handler(app.logger)

    def handleServer():
        app.run(debug=False, use_reloader=False, host=config.service_ip, port='8506')
        
    handler.start(handleServer)
