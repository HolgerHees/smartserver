#!/usr/bin/python3

from flask import Flask, request, make_response
import logging
import socket

import glob

import pyinotify

import pexpect 
import subprocess
import threading
import json
import sys
import os
import importlib
import time

from datetime import datetime, timezone
from json.decoder import JSONDecodeError
from pexpect.exceptions import EOF, TIMEOUT

from config import config

sys.path.insert(0, "/opt/shared/python")

from smartserver.server import Server

from lib import helper
from lib import status
from lib import service
from lib import job
from lib import git
from lib import log

watched_data_files = [
]

env_path = "/sbin:/usr/sbin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin"

app = Flask(__name__)

log.setLogger(app.logger)

class Handler(Server):
    def __init__(self):
        super().__init__("ci_service", watched_data_files + [__file__])
        
        self.cleanJobs()
        
    def _cleanJobs(self):
        service.showRunningJobs()
        
        if service.getPid() is None:
            running_jobs = glob.glob(u"{}*-*-running-*-*.log".format(config.log_dir))
            if len(running_jobs) > 0:
                for name in running_jobs:
                    app.logger.info("Clean '{}'".format(name))
                    os.rename(name, name.replace("-running-","-failed-"))

                service.cleanRunningJobs("all")
          
    def cleanJobs(self):
        thread = threading.Thread(target=self._cleanJobs, args=())
        thread.start()
        
    def getState(self):
        pass
      
@app.route('/state/', methods = ['POST'])
def state():     
    return handler.getState()

if __name__ == '__main__':
    handler = Handler()
    
    app.logger.setLevel(logging.DEBUG)
    app.run(debug=False, use_reloader=False, host=config.daemon_ip, port='8506')
