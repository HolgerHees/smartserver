#!/usr/bin/python3

from flask import Flask, request, make_response
import logging

import glob

import signal

import threading
import sys
import os
import time

import json

from config import config

sys.path.insert(0, "/opt/shared/python")

from smartserver.server import Server
from smartserver.github import GitHub

from lib import helper
from lib import status
from lib import service
from lib import job
from lib import git
from lib import log

repository_owner = GitHub.getRepositoryOwner(config.repository_url)

watched_data_files = [
    config.status_file
]

cmd_service_restart = "systemctl restart"

env_path = "/sbin:/usr/sbin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin"

app = Flask(__name__)

log.setLogger(app.logger)

class Handler(Server):
    def __init__(self):
        super().__init__("ci_service", watched_data_files + [__file__])
        
        self.terminated = False
        
        self.state = status.getState(config.status_file)
        self.job_is_running = self._isJobRunning()
        
        thread = threading.Thread(target=self._jobWatcher, args=())
        thread.start()
        
    def _isJobRunning(self):
        return service.getPid() is not None
      
    def _jobWatcher(self):
        self._cleanJobs()

        while not self.terminated:
            if self.hasFileChanged(config.status_file):
                self.state = status.getState(config.status_file)
                self.confirmFileChanged(config.status_file)
                self.job_is_running = True
            else:
                job_is_running = self._isJobRunning()
                if self.job_is_running != job_is_running:
                    if not job_is_running and self.state["status"] == "running":
                        app.logger.info("Job crash detected. Marked as 'crashed' now and check log files.")
                        status.setState(config.status_file,u"crashed")
                        
                        self._cleanJobs()

                    self.job_is_running = job_is_running
          
            time.sleep( 15 if self.job_is_running else 60 )
      
    def _cleanJobs(self):
        running_jobs = glob.glob(u"{}*-*-running-*-*.log".format(config.log_dir))
        if len(running_jobs) > 0:
            cleaned_running_jobs = []
            
            # collect git hashes and logfiles
            git_hashes = {}
            for name in running_jobs:
                details = job.getLogFileDetails(name)
                if self.job_is_running:
                    if details["config"] == self.state["config"] and details["deployment"] == self.state["deployment"] and details["git_hash"] == self.state["git_hash"]:
                        continue
                      
                cleaned_running_jobs.append(name)
                if details["git_hash"] not in git_hashes:
                    git_hashes[details["git_hash"]] = []
                    
                git_hashes[details["git_hash"]].append(details["deployment"])
                            
            if config.access_token != "":
                # process git hashes
                for git_hash in git_hashes: 
                    app.logger.info("Clean states of git hash '{}'".format(git_hash))
                    GitHub.setState(repository_owner,config.access_token,git_hash,"error", self.state["deployment"],"Build crashed")
                    GitHub.cancelPendingStates(repository_owner, config.access_token, stopped_state_obj["git_hash"], "Build skipped")

            # process logfiles
            for name in cleaned_running_jobs:
                app.logger.info("Clean file '{}'".format(name))
                os.rename(name, name.replace("-running-","-crashed-"))
            
            if service.getPid() is not None:
                service.cleanRunningJobs("all")
          
    def restartDaemon(self):
        result = helper.execCommand(u"{} ci_service 2>&1".format(cmd_service_restart))
        if cloneResult.returncode == 0:
            return self.getState()
        else:
            return json.dumps({ 
                "status": cloneResult.returncode,
                "message": "Daemon restart failed with message ''".format(cloneResult.stdout.decode("utf-8"))
            })
          
    def getState(self):
        return json.dumps({ 
            "status": 0,
            "job_is_running": self.job_is_running,
            "ci_server_needs_restart": self.hasFileChanged(__file__)
        })
      
    def terminate(self):
        self.terminated = True
      
@app.route('/state/', methods = ['POST'])
def state():     
    return handler.getState()
  
@app.route('/restartDaemon/', methods = ['POST'])
def restartDaemon():
    return handler.restartDaemon()

#def cleanup(signum, frame):
#    print("Shutdown daemon", flush=True)
#    handler.terminate()
#    exit(0)

#signal.signal(signal.SIGTERM, cleanup)
#signal.signal(signal.SIGINT, cleanup)

if __name__ == '__main__':
    handler = Handler()
    
    app.logger.setLevel(logging.DEBUG)
    app.run(debug=False, use_reloader=False, host=config.daemon_ip, port='8506')
