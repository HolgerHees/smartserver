#!/usr/bin/python3

from flask import Flask, request, make_response
from flask_socketio import SocketIO, emit
from werkzeug.serving import WSGIRequestHandler

import logging
import sys

from datetime import datetime

from smartserver.server import Server

from config import config
from lib.handler.arpscan import ArpScanner

from lib.handler.openwrt import OpenWRT
from lib.handler.librenms import LibreNMS
from lib.handler.fritzbox import Fritzbox
from lib.handler.portscan import PortScanner
from lib.handler.gateway import Gateway

from lib.handler.publish_mqtt import MQTTPublisher
from lib.handler.publish_influxdb import InfluxDBPublisher

from lib.dispatcher import Dispatcher
from lib.cache import Cache

app = Flask(__name__ )
app.logger = logging.getLogger()
#app.config['SECRET_KEY'] = 'test!'
#socketio = SocketIO(app, async_mode="threading", logger=logging.getLogger(), cors_allowed_origins="*")
socketio = SocketIO(app, async_mode="threading", cors_allowed_origins="*")

class Handler(Server):
    def __init__(self):
        super().__init__("system_service")
        
        self.startup_timestamp = round(datetime.now().timestamp(),3)
        
        self.pipeline = []
        self.cache = Cache(config)

        self.dispatcher = Dispatcher(config, self.cache, self )
        
        self.dispatcher.register(ArpScanner(config, self.cache ))
        if len(config.openwrt_devices) > 0:
            self.dispatcher.register(OpenWRT(config, self.cache ))
        if len(config.fritzbox_devices) > 0:
            self.dispatcher.register(Fritzbox(config, self.cache ))
        if config.librenms_token:
            self.dispatcher.register(LibreNMS(config, self.cache ))
        self.dispatcher.register(PortScanner(config, self.cache ))
        self.dispatcher.register(Gateway(config, self.cache ))
        self.dispatcher.register(MQTTPublisher(config, self.cache ))
        self.dispatcher.register(InfluxDBPublisher(config, self.cache ))
        
        self.dispatcher.start()
        
    def terminate(self):
        if self.dispatcher:
            self.dispatcher.terminate()
        super().terminate()
        
    def notifyNetworkData(self, changed_data, msg):
        logging.info("Emit changed {}".format(msg))

        with app.app_context():
            socketio.emit('network_data', changed_data)
        #socketio.sleep(5)
        
    def emitNetworkData(self):
        [ data, msg ] = self.dispatcher.getData();

        logging.info("Emit initial {}".format(msg))

        data["root"] = self.cache.getGatewayMAC()
        emit('network_data', data)

    def getStateMetrics(self):
        metrics = self.dispatcher.getStateMetrics()
        return "{}\n".format( "\n".join(metrics) )
          
#@app.route('/state/', methods = ['POST'])
#def state():
#    pass

#https://github.com/miguelgrinberg/Flask-SocketIO/blob/main/example/app.py

@app.route('/metrics/', methods = ['GET'])
def metrics():
    return handler.getStateMetrics()

@socketio.on_error_default
def on_error(e):
    logging.error(e)
    sys.excepthook(*sys.exc_info())

@socketio.on('connect')
def on_connect():
    logging.info("on_connect {}".format(request.sid))
    
@socketio.on('disconnect')
def on_disconnect():
    logging.info("on_disconnect {}".format(request.sid))
    
@socketio.on('call')
def on_call(type):
    logging.info("on_call {}".format(type))
    if type == "network_data":
        handler.emitNetworkData()
    
if __name__ == '__main__':
    Server.initLogger(logging.INFO)

    handler = Handler()

    def handleServer():
        WSGIRequestHandler.protocol_version = "HTTP/1.1"
        socketio.run(app=app, use_reloader=False, host=config.service_ip, port=config.service_port)
        
    handler.start(handleServer)

