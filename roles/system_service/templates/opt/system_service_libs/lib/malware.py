import threading
import logging
import traceback
import time
import socket
import ipaddress
import re

import requests
import json

import schedule
import os
from datetime import datetime

from smartserver.confighelper import ConfigHelper

class Malware(threading.Thread):
    def __init__(self, config, influxdb):
        threading.Thread.__init__(self)

        self.is_running = False

        self.event = threading.Event()

        self.configs = {
            "blocklist": { "do": schedule.every().day.at("01:00"), "version": 1, "url": "https://lists.blocklist.de/lists/all.txt", "process": self._processFail2Ban },
            "ipsum": { "do": schedule.every().day.at("05:00"), "version": 1, "url": "https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt", "process": self._processIPSum } # list is normally updated at 3am
        }

        self.dump_path_template = "/var/lib/system_service/malware_{}.json"
        self.valid_dump_file = {}

        self.map_modified = {}
        self.map_data = {}

        self.max_list_age = 60 * 60 * 24 * 7

    def start(self):
        self.is_running = True
        self._restore()

        for name, config in self.configs.items():
            config["do"].do(lambda: self.fetch(name))

        #influxdb.register(self.getMessurements)

        super().start()

    def terminate(self):
        self.is_running = False
        self.event.set()

    def run(self):
        logging.info("IP attack check started")
        try:
            for name, config in self.configs.items():
                if name not in self.map_data:
                    self.map_data[name] = {}
                    if self.valid_dump_file[name]:
                        self._fetch(name)
            while self.is_running:
                self.event.wait(60)

            logging.info("IP attack check  stopped")
        except Exception:
            logging.error(traceback.format_exc())
            self.is_running = False

    def _restore(self):
        for name, config in self.configs.items():
            self.valid_dump_file[name], data = ConfigHelper.loadConfig(self.dump_path_template.format(name), config["version"])
            if data is not None:
                self.map_data[name] = data["map"]
                self.map_modified[name] = data["map_modified"]
                logging.info("Loaded {} malware {} ip's".format(len(self.map_data[name]), name))

    def _fetch(self, name):
        try:
            response = requests.get(self.configs[name]["url"])
            if response.status_code == 200:
                if len(response.content) > 0:
                    content = response.content.decode("utf-8")
                    lines = []
                    for line in content.splitlines():
                        if len(line.strip()) == 0:
                            continue
                        lines.append(line)

                    map_data, map_modified = self.configs[name]["process"](lines)
                    if map_data is not None:
                        self.map_data[name] = map_data
                        self.map_modified[name] = map_modified

                        ConfigHelper.saveConfig(self.dump_path_template.format(name), self.configs[name]["version"], { "map_modified": self.map_modified[name], "map": self.map_data[name] } )
                        logging.info("Saved {} malware {} ip's".format(name, len(self.map_data[name])))
                    else:
                        logging.error("Error parsing {} list. Got empty map data".format(name))
                else:
                    logging.error("Error fetching {} list. Got empty response".format(name))
            else:
                logging.error("Error fetching {} list. Got code: '{}' and repsonse: '{}'".format(name, response.status_code, response.content))

        except:
            logging.error("Error fetching ipsum list")
            logging.error(traceback.format_exc())
            return

    def _processIPSum(self, lines):
        map_data = {}
        map_modified = None
        for line in lines:
            if line.startswith("#"):
                if line.startswith("# Last update: "):
                    datetime_str = line[15:]
                    map_modified = datetime.timestamp(datetime.strptime(datetime_str, '%a, %d %b %Y %H:%M:%S %z' ))
                continue

            columns = re.split("\s+", line)
            if len(columns) != 2:
                logging.warning("Error fetching ipsum list. Invalid format. '{}'".format(line))
                #return [None, None]
                continue

            amount = int(columns[1])
            if amount < 2:
                continue
            map_data[columns[0]] = amount

        return [map_data, map_modified] if map_modified is not None and len(map_data) > 0 else [None, None]

    def _processFail2Ban(self, lines):
        map_data = {}
        for line in lines:
            map_data[line] = 99

        return [map_data, time.time()] if len(map_data) > 0 else [None, None]

    def check(self, ip):
        for name, config in self.configs.items():
            if ip in self.map_data[name]:
                return name
        return None

    def getStateMetrics(self):
        metrics = [
            "system_service_process{{type=\"malware\",}} {}".format("1" if self.is_running else "0")
        ]

        for name, config in self.configs.items():
            metrics.append("system_service_malware{{listname=\"{}\",type=\"list_state\",}} {}".format(name, 1 if ( name in self.map_modified and self.map_modified[name] > time.time() - self.max_list_age ) else 0))
            metrics.append("system_service_malware{{listname=\"{}\",type=\"list_last_modified\",}} {}".format(name, self.map_modified[name] if name in self.map_modified else 0))
            metrics.append("system_service_malware{{listname=\"{}\",type=\"list_entries\",}} {}".format(name, len(self.map_data[name].keys())))
            metrics.append("system_service_state{{listname=\"{}\",type=\"list_dump\",}} {}".format(name, "1" if self.valid_dump_file[name] else "0"))

        return metrics
