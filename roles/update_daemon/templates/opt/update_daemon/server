#!/usr/bin/python3

from flask import Flask, request, make_response
import logging
import socket

import glob

import pyinotify

import pexpect 
import subprocess
import threading
import json
import sys
import os
import importlib
import time

from datetime import datetime, timezone
from json.decoder import JSONDecodeError
from pexpect.exceptions import EOF, TIMEOUT

from config import config

sys.path.insert(0, "/opt/shared/python")

from smartserver.logfile import LogFile

watched_data_files = [
  config.system_update_state_file,
  config.deployment_state_file,
  config.deployment_tags_file
]

cmd_processlist = "/usr/bin/ps -alx"
cmd_system_update_check = "/opt/update_daemon/system_update_check"
cmd_service_restart = "systemctl restart"
cmd_request_reboot = "reboot"
cmd_check_reboot = "runlevel | grep \"6\""
cmd_container_cleanup = "/opt/docker/cleanup -q"

cmd_mapping = {
    "system_update_check": "update check",
    "daemon_restart": "daemon restart",
    "service_restart": "service restart",
    "system_reboot": "system reboot",
    "system_update": "system update",
    "deployment_update": "deployment update",
}

process_mapping = {
    "system_update_check": "system_update_check",
    "systemctl": "service_restart",
    "rpm": "system_update",
    "yum": "system_update",
    "apt": "system_update",
    "dnf": "system_update",
    "zypper": "system_update",
    "ansible-playbook": "deployment_update",
}

env_path = "/sbin:/usr/sbin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin"

MAX_DAEMON_RESTART_TIME = 30
MAX_SYSTEM_REBOOT_TIME = 600

MIN_PROCESS_INACTIVITY_TIME = 30
MAX_STARTUP_WAITING_TIME = 180

START_TIME_STR_FORMAT = "%Y.%m.%d_%H.%M.%S"

app = Flask(__name__)

class Identity(pyinotify.ProcessEvent):
    def __init__(self, s):
        super().__init__(s)
        self.modified_time = {}
        
    def process_default(self, event):
        self.modified_time[event.path] = datetime.timestamp(datetime.now())
        
    def addWatcher(self,path,wm):
        file_stat = os.stat(path)
        self.modified_time[path] = file_stat.st_mtime
        wm.add_watch(path, pyinotify.IN_DELETE_SELF | pyinotify.IN_CLOSE_WRITE | pyinotify.IN_MODIFY, rec=True, auto_add=True)
        
    def getModifiedTime(self,path):
        return self.modified_time[path]

# Thread #1

class Handler(pyinotify.ProcessEvent):
    def __init__(self):
      
        self._lock_socket = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
        try:
            # The null byte (\0) means the socket is created 
            # in the abstract namespace instead of being created 
            # on the file system itself.
            # Works only in Linux
            self._lock_socket.bind('\0update_daemon')
        except socket.error:
            return
        
        wm = pyinotify.WatchManager()
        s = pyinotify.Stats()
        self.identity = Identity(s)
        notifier = pyinotify.ThreadedNotifier(wm, default_proc_fun=self.identity)
        notifier.start()
        
        self.identity.addWatcher(__file__,wm)
        self.update_server_time = self.identity.getModifiedTime(__file__)
        
        self.watched_data_files = {}
        for watched_data_file in watched_data_files:
            if not os.path.isfile(watched_data_file):
                self.watched_data_files[watched_data_file] = None
            else:
                self.identity.addWatcher(watched_data_file,wm)
                self.watched_data_files[watched_data_file] = os.path.basename(watched_data_file)
            
        self.last_jobs_modified = datetime.timestamp(datetime.now())

        self.current_cmd_type = None
        self.current_started = None
        self.current_logfile = None
        self.current_child = None
       
        self.handleRunningStates()
        
        self.testWorkflow = True

    def prepareTestWorkflow(self,cmd_block):
        for cmd in cmd_block["cmds"]:
            interaction = cmd["interaction"]
            cmd["interaction"] = "****" if interaction else interaction
            cmd["cmd"] = "/*" + cmd["cmd"] + "*/ => sleep 5"
            app.logger.info(cmd)
            cmd["interaction"] = interaction
            cmd["cmd"] = "sleep 5"

    def restoreLock(self,cmd_type,start_time,file_name):
        self.current_cmd_type = cmd_type
        self.current_started = start_time
        self.current_logfile = file_name
      
    def lock(self, cmd_type):
        if self.current_child != None:
            return False
        else:
            self.current_cmd_type = cmd_type
            self.current_started = datetime.now()
            return True

    def unlock(self, exit_code):
        self.last_jobs_modified = datetime.timestamp(datetime.now())
        
        self.current_cmd_type = None
        self.current_started = None
        self.current_logfile = None
        self.current_child = None

    def buildSuccessResult(self, running_type, cmd_type):
        #app.logger.info(__file__)
        
        last_data_modified = {}
        for watched_data_file in self.watched_data_files:
            if self.watched_data_files[watched_data_file] is not None:
                last_data_modified[self.watched_data_files[watched_data_file]] = self.identity.getModifiedTime(watched_data_file)
            else:
                last_data_modified[self.watched_data_files[watched_data_file]] = 0
                
        last_data_modified["job.state"] = self.last_jobs_modified
                
        return json.dumps({ 
            "status": 0, 
            "job_is_running": running_type is not None, 
            "job_running_type": running_type, 
            "job_cmd_name": cmd_mapping[cmd_type] if cmd_type is not None else "", 
            "job_started": self.current_started.isoformat() if self.current_started is not None else None, 
            "job_logfile": self.current_logfile,
            "job_killable": self.current_cmd_type != "system_reboot",
            "last_data_modified": last_data_modified,
            "update_server_needs_restart": self.update_server_time != self.identity.getModifiedTime(__file__)
        })

    def buildErrorResult(self, status, message):
        return json.dumps({ 
            "status": status, 
            "message": message
        })
      
    def finishRun(self,job_log_file,exit_status,start_time,start_time_str,cmd_type,username):
        duration = datetime.now() - start_time
        status_msg = "success" if exit_status == 0 else "failed"
        finished_log_name = u"{}-{}-{}-{}-{}.log".format(start_time_str,round(duration.total_seconds(),1),status_msg, cmd_type,username)
        finished_log_file = u"{}{}".format(config.job_log_folder,finished_log_name)

        os.rename(job_log_file, finished_log_file)
        self.current_logfile = finished_log_name
        self.unlock(exit_status)

    def runCmd(self,cmd_type, _cmd, lf):
        start_time = datetime.now()
        
        cmd = _cmd["cmd"]
        interaction = _cmd["interaction"]
        cwd = _cmd["cwd"]
        env = _cmd["env"]

        msg = u"Start cmd '{}' - '{}'".format(cmd_type, cmd)
        app.logger.info(msg)
        lf.write(u"{}\n".format(msg))
        
        if env is None:
            env = {}
        #env["PATH"] = env_path

        self.current_child = pexpect.spawn(cmd, timeout=3600, cwd=cwd, env=env)
        self.current_child.logfile_read = lf
        
        if interaction is not None:
            patterns = list(interaction.keys())
            responses = list(interaction.values())
        else:
            patterns = None
            responses = None
            
        while self.current_child.isalive():
            try:
                index = self.current_child.expect(patterns)
                self.current_child.sendline(responses[index])
            except TIMEOUT:
                break
            except EOF:
                break

        self.current_child.close()
        exit_status = self.current_child.exitstatus

        duration = datetime.now() - start_time
        lf.getFile().write("\n")
        if exit_status == 0:
            lf.write("The command '{}' exited with 0 (successful) after {}.\n".format(cmd,duration.total_seconds()))
        else:
            lf.write("The command '{}' exited with {} (unsuccessful) after {}.\n".format(cmd,exit_status,duration.total_seconds()))
            
        return exit_status
  
    def runCmdBlock(self, cmd_block):
        username = cmd_block["username"]
        cmd_type = cmd_block["cmd_type"]
        
        start_time = datetime.now()
        start_time_str = start_time.strftime(START_TIME_STR_FORMAT)
        job_log_name = u"{}-{}-{}-{}-{}.log".format(start_time_str,0,"running", cmd_type,username)
        job_log_file = u"{}{}".format(config.job_log_folder,job_log_name)
        exit_status = 1
        with open(job_log_file, 'w') as f:
            self.current_logfile = job_log_name
            try:
                lf = LogFile(f)
                
                for _cmd in cmd_block["cmds"]:
                    exit_status = self.runCmd(cmd_type,_cmd,lf)
                    
                    if exit_status != 0:
                        break

            except ValueError:
                #app.logger.warn(traceback.format_exc())
                pass
            except Exception as e:
                exit_status = 1
                lf.write("The command '{}' exited with '{}'.\n".format(cmd,str(e)))
                     
        #if os.path.isfile(job_log_file):
        if cmd_type != "system_reboot":
            self.finishRun(job_log_file, exit_status,start_time,start_time_str,cmd_type,username)

        return exit_status
 
    def startCommand(self, cmd_block):
        active_cmd_type = self.checkProcesses()
        if active_cmd_type is None and self.lock(cmd_block["cmd_type"]):
            return self.runCmdBlock(cmd_block)
        else:
            return -1
          
    def startThread(self, cmd_block):
        active_cmd_type = self.checkProcesses()
        if active_cmd_type is None and self.lock(cmd_block["cmd_type"]):
            thread = threading.Thread(target=self.runCmdBlock, args=(cmd_block, ))
            thread.start()
            return state()
        else:
            return self.buildErrorResult(exit_status, "Command '{}' not started".format(cmd_block["cmd_type"]) )
      
    def killProcess(self):
        child = self.current_child
        if child is not None:
            subprocess.call(['sudo', 'kill', str(child.pid)])
        return state()

    def checkProcesses(self):
        result = subprocess.run([ cmd_processlist ], shell=True, check=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=None )
        stdout = result.stdout.decode("utf-8")
        active_cmd_type = None
        for term in process_mapping:
            if "{} ".format(term) in stdout:
                active_cmd_type = process_mapping[term]
                break
        return active_cmd_type
      
    def getState(self):
        active_cmd_type = self.checkProcesses()
        
        if self.current_cmd_type:
            return self.buildSuccessResult("daemon",self.current_cmd_type)
        elif active_cmd_type:
            return self.buildSuccessResult("manual",active_cmd_type)
        else:
            return self.buildSuccessResult(None, None)
          
    def buildCmd(self, cmd, interaction, cwd, env ):
        return { "cmd": cmd, "interaction": interaction, "cwd": cwd, "env": env }
      
    def buildCmdBlock(self, username, cmd_type, cmds ):
        return { "username": username, "cmd_type": cmd_type, "cmds": cmds }
      
    def buildFunction(self, username, function, params ):
        return { "username": username, "function": function, "params": params }

    def buildPostCheckCmd(self, check_type):
        cmd = u"{} {}".format(cmd_system_update_check, check_type)
        return self.buildCmd(cmd, interaction=None,cwd=None,env=None)
      
    def buildSystemUpdateCheckCmd(self, username):
        cmd = self.buildCmd(cmd_system_update_check, interaction=None,cwd=None,env=None)
        return self.buildCmdBlock(username, "system_update_check", [cmd])
          
    def buildRestartServiceCmd(self, username, services):
        cmd_service_restart_with_services = "{} {}".format(cmd_service_restart, services.replace(","," "))
        cmd = self.buildCmd(cmd_service_restart_with_services, interaction=None,cwd=None,env=None)
        post_cmd = self.buildPostCheckCmd("system_state")
        return self.buildCmdBlock(username, "service_restart", [cmd,post_cmd])

    def buildRestartDaemonCmd(self, username):
        cmd_daemon_restart = "{} update_daemon".format(cmd_service_restart)
        cmd = self.buildCmd(cmd_daemon_restart, interaction=None,cwd=None,env=None)
        return self.buildCmdBlock(username, "daemon_restart", [cmd])

    def buildInstallSystemUpdateCmd(self, username):
        plugin = importlib.import_module("plugins.os.{}".format(config.os_type))
        repo = plugin.Repository()
        cmd_install_system_updates = repo.getSystemUpdateCmd()
        cmd = self.buildCmd(cmd_install_system_updates, interaction=None,cwd=None,env=None)
        post_cmd = self.buildPostCheckCmd("system")
        return self.buildCmdBlock(username, "system_update", [cmd,post_cmd])

    def buildDeploymentSmartserverUpdateCmd(self, username, password, tags):
        deployment_state = None
        if os.path.isfile(config.deployment_state_file):
            with open(config.deployment_state_file, 'r') as f:
                try:
                    deployment_state = json.load(f)
                except JSONDecodeError:
                    pass
        if deployment_state is not None:
            cmd_deploy_system = "ansible-playbook -i config/{}/{}".format(deployment_state["config"],deployment_state["server"])
            if password:
                cmd_deploy_system = "{} --ask-vault-pass".format(cmd_deploy_system) 
                interaction = {"Vault password:": "{}\n".format(password)}
            else:
                interaction = None
            if tags:
                if request.form["confirm"] == "1":
                    tags = u"{},confirm_deployment".format(tags)
                cmd_deploy_system = "{} --tags \"{}\"".format(cmd_deploy_system,tags) 
            cmd_deploy_system = "{} server.yml".format(cmd_deploy_system)

            cmd = self.buildCmd(cmd_deploy_system, interaction=interaction,cwd=config.git_directory,env={"ANSIBLE_FORCE_COLOR": "1"})
            post_cmd = self.buildPostCheckCmd("deployment_update")
            clean_cmd = self.buildCmd(cmd_container_cleanup, interaction=None,cwd=None,env=None)
            return self.buildCmdBlock(username, "deployment_update", [cmd,post_cmd,clean_cmd])
        else:
            return None

    def buildSystemRebootCmd(self, username):
        cmd = self.buildCmd(cmd_request_reboot, interaction=None,cwd=None,env=None)
        post_cmd = self.buildPostCheckCmd("system")
        return self.buildCmdBlock(username, "system_reboot", [cmd,post_cmd])

    def _getSystemUpdateState(self):
        states = None
        if os.path.isfile(config.system_update_state_file):
            with open(config.system_update_state_file, 'r') as f:
                states = json.load(f)
        return states
      
    def buildDeploymentUpdateIfNecessary(self,username,params):
        states = self._getSystemUpdateState()
        if states and len(states["smartserver_changes"]) > 0:
            return self.buildDeploymentSmartserverUpdateCmd(username, params["password"] if "password" in params else None, None)
        return None

    def buildSystemUpdateIfNecessary(self,username,params):
        states = self._getSystemUpdateState()
        if states and len(states["os_updates"]) > 0:
            return self.buildInstallSystemUpdateCmd(username)
        return None

    def buildRestartServiceIfNecessary(self, username,params):
        states = self._getSystemUpdateState()
        if states and len(states["os_outdated"]) > 0:
            services = []
            for line in states["os_outdated"]:
                if not line["service"]:
                    continue
                services.append(line["service"])
            if len(services) > 0:
                return self.buildRestartServiceCmd(username,",".join(services))

        return None
        
    def buildSystemRebootCmdIfNecessary(self, username,params):
        states = self._getSystemUpdateState()
        if states:
            reboot_needed = True
            if len(states["os_outdated"]) > 0:
                services = []
                for line in states["os_outdated"]:
                    if line["service"]:
                        continue
                    reboot_needed = True
                    break

            if reboot_needed or states["os_reboot"]:
                return self.buildSystemRebootCmd(username)

        return None
      
    def handleDaemonRestart(self,file_name,file_age,start_time_str):
        is_success = file_age < MAX_DAEMON_RESTART_TIME
        
        with open(file_name, 'a') as f:
            lf = LogFile(f)
            lf.getFile().write("\n")
            if is_success:
                lf.write("The command was successful.\n")
            else:
                lf.write("The command crashed.\n")
            
        os.rename(file_name, file_name.replace("-running-","-success-" if is_success else "-failed-"))
        
        return is_success
        
    def handleSystemReboot(self,file_name,file_age,start_time_str):
        is_success = file_age < MAX_SYSTEM_REBOOT_TIME
        
        if is_success:
            if os.path.isfile(config.deployment_workflow_file):
                with open(config.deployment_workflow_file, 'r') as f:
                    workflow = json.load(f)
                    if workflow[0]["cmd_type"] == "system_reboot":
                        return self.proceedSystemReboot(workflow,file_name,start_time_str)
                    else:
                        error_msg = "Can't continue. Wrong first workflow.\n"
            else:
                error_msg = "Can't continue. Missing workflow file.\n"
        else:
            error_msg = "The command crashed.\n"

        with open(file_name, 'a') as f:
            lf = LogFile(f)
            lf.getFile().write("\n")
            lf.write(error_msg)
        os.rename(file_name, file_name.replace("-running-","-failed-"))
        
        return False

    def handleCrash(self,file_name):
        with open(file_name, 'a') as f:
            lf = LogFile(f)
            lf.getFile().write("\n")
            lf.write("The command crashed.\n")

        os.rename(file_name, file_name.replace("-running-","-failed-"))
        
        return False
      
    def _handleRunningStates(self):
        for name in glob.glob(u"{}*-*-running-*-*.log".format(config.job_log_folder)):
            log_mtime = os.stat(name).st_mtime
            log_modified_time = datetime.fromtimestamp(log_mtime, tz=timezone.utc)
            file_age = datetime.timestamp(datetime.now()) - datetime.timestamp(log_modified_time)

            name_parts = os.path.basename(name).split("-")
            
            result = False
            if name_parts[3] == "daemon_restart":
                result = self.handleDaemonRestart(name,file_age,name_parts[0])
            elif name_parts[3] == "system_reboot":
                result = self.handleSystemReboot(name,file_age,name_parts[0])
            else:
                result = self.handleCrash(name)

            if type(result) == bool:
                app.logger.info("Mark job '{}' as '{}'".format(name_parts[3], 'success' if result else 'failed'))
            else:
                app.logger.info("Proceed with job '{}'".format(name_parts[3]))
      
         
        if os.path.isfile(config.deployment_workflow_file):
            os.unlink(config.deployment_workflow_file)

    def handleRunningStates(self):
        thread = threading.Thread(target=self._handleRunningStates, args=())
        thread.start()

    def _proceedSystemReboot(self,workflow, file_name, start_time_str):
        min_inactivity_time = MIN_PROCESS_INACTIVITY_TIME
        max_waiting_time = MAX_STARTUP_WAITING_TIME
        
        start_time = datetime.strptime(start_time_str, START_TIME_STR_FORMAT) 

        exit_status = 1
        with open(file_name, 'a') as f:
            cmd_block = workflow.pop(0)

            self.restoreLock(cmd_block["cmd_type"],start_time,file_name)
            lf = LogFile(f)

            can_proceed = False
            waiting_start = datetime.timestamp(datetime.now())
            last_seen_cmd_type = waiting_start
            while True:
                now = datetime.timestamp(datetime.now())
                waiting_time = round(now - waiting_start)
                inactivity_time = now - last_seen_cmd_type

                if waiting_time % 2 == 0:
                    active_cmd_type = self.checkProcesses()
                    if active_cmd_type is not None:
                        last_seen_cmd_type = now

                    if inactivity_time > min_inactivity_time:
                        can_proceed = True
                        break

                    if waiting_time > max_waiting_time:
                        lf.getFile().write("\n")
                        lf.write("Not able to proceed. There are still some processed running\n")
                        break
                  
                if waiting_time % 15 == 0:
                    app.logger.info("Waiting for process inactivity. [Inactive: {} sec (min: {}), Waiting: {} secs (max: {}]".format(round(inactivity_time),min_inactivity_time,round(waiting_time),max_waiting_time))
                    
                time.sleep(1)

            if can_proceed:
                try:
                    if self.testWorkflow:
                        self.prepareTestWorkflow(cmd_block)
                    
                    for cmd in cmd_block["cmds"]:
                        exit_status = self.runCmd(cmd_block["cmd_type"], cmd, lf)

                        if exit_status != 0:
                            break

                except ValueError:
                    #app.logger.warn(traceback.format_exc())
                    pass
                except Exception as e:
                    exit_status = 1
                    lf.write("The command '{}' exited with '{}'.\n".format(cmd,str(e)))
                 
        self.finishRun(file_name,exit_status,start_time,start_time_str,cmd_block["cmd_type"],cmd_block["username"])
                      
        self._runWorkflow(workflow)
        
    def proceedSystemReboot(self,workflow,file_name,start_time_str):
        thread = threading.Thread(target=self._proceedSystemReboot, args=(workflow, file_name, start_time_str))
        thread.start()

    def _runWorkflow(self, workflow):
        while len(workflow) > 0:
            cmd_block = workflow.pop(0)
            if "function" in cmd_block:
                function = getattr(self, cmd_block["function"])
                _cmd_block = function(cmd_block["username"], cmd_block["params"])
                if _cmd_block is None:
                    app.logger.info("Skip workflow function '{}'".format(cmd_block["function"]))
                    continue
                else:
                    cmd_block = _cmd_block

            if cmd_block["cmd_type"] == "system_reboot":
                with open(config.deployment_workflow_file, 'w') as f:
                    first_cmd = cmd_block["cmds"].pop(0)
                    workflow.insert(0,cmd_block)
                    json.dump(workflow, f)
                    
                    cmd_block = self.buildCmdBlock(cmd_block["username"], cmd_block["cmd_type"], [first_cmd])
                
            if self.testWorkflow:
                self.prepareTestWorkflow(cmd_block)
                
            exit_code = self.startCommand(cmd_block)
            if exit_code != 0:
                if os.path.isfile(config.deployment_workflow_file):
                    os.unlink(config.deployment_workflow_file)
                app.logger.error("Command '{}' exited with code '{}'".format(cmd_block["cmd_type"],exit_code));
                break
          
            if cmd_block["cmd_type"] == "system_reboot":
                break
              
    def runWorkflow(self, workflow):
        thread = threading.Thread(target=self._runWorkflow, args=(workflow, ))
        thread.start()
        return state()
      
@app.route('/state/', methods = ['POST'])
def state():     
    return handler.getState()
  
@app.route('/refreshSystemUpdateCheck/', methods = ['POST'])
def refreshSystemUpdateCheck():
    cmd = handler.buildSystemUpdateCheckCmd(request.form['username'])
    return handler.startThread(cmd)

@app.route('/restartService/', methods = ['POST'])
def restartService():
    cmd = handler.buildRestartServiceCmd(request.form['username'],request.form["service"])
    return handler.startThread(cmd)
      
@app.route('/restartDaemon/', methods = ['POST'])
def restartDaemon():
    cmd = handler.buildRestartDaemonCmd(request.form['username'])
    return handler.startThread(cmd)

@app.route('/installSystemUpdates/', methods = ['POST'])
def installSystemUpdates():
    cmd = handler.buildInstallSystemUpdateCmd(request.form['username'])
    return handler.startThread(cmd)

@app.route('/deploySmartserverUpdates/', methods = ['POST'])
def deploySmartserverUpdates():
    cmd = handler.buildDeploymentSmartserverUpdateCmd(request.form['username'], request.form["password"] if "password" in request.form else None, request.form["tags"] if request.form["tags"] else None )
    if cmd:
        return handler.startThread(cmd)
    else:
        return self.buildErrorResult("501", "Deployment state file missing, empty or not readable")

@app.route('/systemReboot/', methods = ['POST'])
def systemReboot():
    workflow = [
        handler.buildSystemRebootCmd(request.form['username']),
    ]
    return handler.runWorkflow(workflow);

@app.route('/updateWorkflow/', methods = ['POST'])
def updateWorkflow():
    workflow = [
        handler.buildFunction( request.form['username'], "buildSystemUpdateIfNecessary", request.form ),
        handler.buildFunction( request.form['username'], "buildRestartServiceIfNecessary", request.form ),
        handler.buildFunction( request.form['username'], "buildSystemRebootCmdIfNecessary", request.form ),
        handler.buildFunction( request.form['username'], "buildDeploymentUpdateIfNecessary", request.form )
    ]
    return handler.runWorkflow(workflow);

@app.route('/killProcess/', methods = ['POST'])
def killProcess():
    return handler.killProcess()

if __name__ == '__main__':
    handler = Handler()
    
    app.logger.setLevel(logging.DEBUG)
    app.run(debug=False, use_reloader=False, host=config.daemon_ip, port='8505')
