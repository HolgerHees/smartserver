#!/usr/bin/python3

from flask import Flask, request, make_response
import logging

import pyinotify

import pexpect 
import subprocess
import threading
import json
import sys
import os
import importlib
from datetime import datetime
from json.decoder import JSONDecodeError
from pexpect.exceptions import EOF, TIMEOUT

from config import config

sys.path.insert(0, "/opt/shared/python")

from smartserver.logfile import LogFile

cmd_processlist = "/usr/bin/ps -alx"
cmd_system_update_check = "/opt/update_daemon/system_update_check"
cmd_service_restart = "systemctl restart"
cmd_request_reboot = "reboot"
cmd_check_reboot = "runlevel | grep \"6\""

cmd_mapping = {
    "system_update_check": "update check",
    "service_restart": "service restart",
    "system_reboot": "system reboot",
    "system_update": "system update",
    "deployment_update": "deployment update",
}

process_mapping = {
    "system_update_check": "system_update_check",
    "systemctl": "service_restart",
    "rpm": "system_update",
    "yum": "system_update",
    "apt": "system_update",
    "dnf": "system_update",
    "zypper": "system_update",
    "ansible": "deployment_update",
}

START_TIME_STR_FORMAT = "%Y.%m.%d_%H.%M.%S"


class Identity(pyinotify.ProcessEvent):
    def __init__(self, s):
        super().__init__(s)
        self.startup_time = datetime.now()
        self.modified_time = self.startup_time
        
    def process_default(self, event):
        app.logger.info(event)
        self.modified_time = datetime.now()
        
    def hasChanged(self):
        app.logger.info(self.startup_time != self.modified_time)
        return self.startup_time != self.modified_time

# Thread #1

class Handler(pyinotify.ProcessEvent):
    def __init__(self):
        wm = pyinotify.WatchManager()
        s = pyinotify.Stats()
        self.identity = Identity(s)
        notifier = pyinotify.ThreadedNotifier(wm, default_proc_fun=self.identity)
        notifier.start()
        wm.add_watch(__file__, pyinotify.IN_DELETE_SELF | pyinotify.IN_CLOSE_WRITE | pyinotify.IN_MODIFY, rec=True, auto_add=True)
        
        self.current_cmd_type = None
        self.current_started = None
      
        self.last_exit_code = 0
        self.last_cmd_type = None
        self.last_duration = 0
        
    def lock(self, cmd_type):
        self.current_cmd_type = cmd_type
        self.current_started = datetime.now()

    def unlock(self, exit_code):
        self.last_exit_code = exit_code
        self.last_cmd_type = self.current_cmd_type
        self.last_duration = ( datetime.now() - self.current_started ).total_seconds() if self.current_started is not None else 0 # 'None' can happen on server restart
        
        self.current_cmd_type = None
        self.current_started = None

    def buildSuccessResult(self, running_type, cmd_type):
        #app.logger.info(__file__)
        
        if os.path.isfile(config.system_update_state_file):
            update_state_file_stat = os.stat(config.system_update_state_file)
            last_data_mtime = update_state_file_stat.st_mtime
        else:
            last_data_mtime = 0
            
        return json.dumps({ 
            "status": 0, 
            "job_is_running": running_type is not None, 
            "job_running_type": running_type, 
            "job_cmd_name": cmd_mapping[cmd_type] if cmd_type is not None else "", 
            "job_started": self.current_started.isoformat() if self.current_started is not None else None, 
            "last_job_status": self.last_exit_code, 
            "last_job_cmd_name": cmd_mapping[self.last_cmd_type] if self.last_cmd_type is not None else "",
            "last_job_duration": self.last_duration,
            "last_data_modified": last_data_mtime,
            "update_server_needs_restart": self.identity.hasChanged()
        })

    def buildErrorResult(self, status, message):
        return json.dumps({ 
            "status": status, 
            "message": message
        })

    def run(self, cmd, cmd_type, post_system_update, interaction, cwd, env):
        start_time = datetime.now()
        start_time_str = start_time.strftime(START_TIME_STR_FORMAT)
        job_log_file = u"{}{}-{}.log".format(config.job_log_folder,start_time_str,cmd_type)
        exit_status = 1
        with open(job_log_file, 'w') as f:
            try:
                app.logger.info(u"Start cmd '{}'".format(cmd))

                lf = LogFile(f)
                child = pexpect.spawn(cmd, timeout=3600, cwd=cwd, env=env)
                child.logfile_read = lf
                
                if interaction is not None:
                    patterns = list(interaction.keys())
                    responses = list(interaction.values())
                else:
                    patterns = None
                    responses = None
                    
                while child.isalive():
                    try:
                        index = child.expect(patterns)
                        child.sendline(responses[index])
                    except TIMEOUT:
                        break
                    except EOF:
                        break

                child.close()
                exit_status = child.exitstatus

                duration = datetime.now() - start_time
                f.write("\n")
                if exit_status == 0:
                    lf.write("The command '{}' exited with 0 (successful) after {}.\n".format(cmd,duration.total_seconds()))
                else:
                    lf.write("The command '{}' exited with {} (unsuccessful) after {}.\n".format(cmd,exit_status,duration.total_seconds()))

                if exit_status == 0 and post_system_update:
                    start_time = datetime.now()
                    post_cmd = u"{} {}".format(cmd_system_update_check, post_system_update)

                    app.logger.info(u"Start post cmd '{}'".format(post_cmd))

                    f.write("\n")
                    
                    child = pexpect.spawn(post_cmd, timeout=180, cwd=cwd)
                    child.logfile_read = lf
                    child.wait()
                    child.close()
                    exit_status = child.exitstatus

                    duration = datetime.now() - start_time
                    f.write("\n")
                    if exit_status == 0:
                        lf.write("The command '{}' exited with 0 (successful) after {}.\n".format(post_cmd,duration.total_seconds()))
                    else:
                        lf.write("The command '{}' exited with {} (unsuccessful) after {}.\n".format(post_cmd,exit_status,duration.total_seconds()))
            except ValueError:
                #app.logger.warn(traceback.format_exc())
                pass
              
        self.unlock(exit_status)

        return exit_status

    def startCommand(self, cmd, cmd_type, post_system_update, interaction, cwd, env):
        active_cmd_type = self.checkProcesses()
        if active_cmd_type is None:
            self.lock(cmd_type)
            exit_status = run(cmd, cmd_type, post_system_update, interaction, cwd)
            self.unlock(exit_status)

            if exit_status == 0:
                return self.buildSuccessResult(False,None)
            else:
                return self.buildErrorResult(exit_status, "Command '{}' exited with code '{}'".format(cmd,exit_status) )
        else:
            return state()
          
    def startThread(self, cmd, cmd_type, post_system_update, interaction, cwd, env):
        active_cmd_type = self.checkProcesses()
        if active_cmd_type is None:
            self.lock(cmd_type)
            
            thread = threading.Thread(target=self.run, args=(cmd, cmd_type, post_system_update, interaction, cwd, env, ))
            thread.start()
        return state()

    def checkProcesses(self):
        result = subprocess.run([ cmd_processlist ], shell=True, check=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=None )
        stdout = result.stdout.decode("utf-8")
        active_cmd_type = None
        for term in process_mapping:
            if "{} ".format(term) in stdout:
                active_cmd_type = process_mapping[term]
                break
        return active_cmd_type
      
    def getState(self):
        active_cmd_type = self.checkProcesses()
        
        if self.current_cmd_type:
            return self.buildSuccessResult("daemon",self.current_cmd_type)
        elif active_cmd_type:
            return self.buildSuccessResult("manual",active_cmd_type)
        else:
            return self.buildSuccessResult(None, None)
      
app = Flask(__name__)
handler = Handler()

@app.route('/state/', methods = ['POST'])
def state():     
    return handler.getState()
  
@app.route('/refreshSystemUpdateCheck/', methods = ['POST'])
def refreshSystemUpdateCheck():
    return handler.startThread(cmd_system_update_check,"system_update_check",None,interaction=None,cwd=None,env=None)

@app.route('/restartService/', methods = ['POST'])
def restartService():
    services = request.form["service"].split(",")
    cmd = "{} {}".format(cmd_service_restart, " ".join(services))
    return handler.startThread(cmd,"service_restart","system_state",interaction=None,cwd=None,env=None)
      
@app.route('/systemReboot/', methods = ['POST'])
def systemReboot():
    return handler.startThread(cmd,"system_reboot","system_state",interaction=None,cwd=None,env=None)

@app.route('/installSystemUpdates/', methods = ['POST'])
def installSystemUpdates():
    plugin = importlib.import_module("plugins.os.{}".format(config.os_type))
    repo = plugin.Repository()
    cmd = repo.getSystemUpdateCmd()
    return handler.startThread(cmd, "system_update","system_update",interaction=None,cwd=None,env=None)

@app.route('/deploySmartserverUpdates/', methods = ['POST'])
def deploySmartserverUpdates():
    if os.path.isfile(config.deployment_state_file):
        deployment_state = None
        with open(config.deployment_state_file, 'r') as f:
            try:
                deployment_state = json.load(f)
            except JSONDecodeError:
                pass
        if deployment_state is not None:
            cmd = "ansible-playbook -i config/{}/{}".format(deployment_state["config"],deployment_state["server"])
            if "password" in request.form:
                cmd = "{} --ask-vault-pass".format(cmd) 
                interaction = {"Vault password:": "{}\n".format(request.form["password"])}
            else:
                interaction = None
            if request.form["tags"]:
                tags = request.form["tags"]
                if request.form["confirm"] == "1":
                    tags = u"{},confirm_deployment".format(tags)
                cmd = "{} --tags \"{}\"".format(cmd,tags) 
            cmd = "{} server.yml".format(cmd)
            
            return handler.startThread(cmd, "deployment_update","deployment_update",interaction=interaction,cwd=config.git_directory,env={"ANSIBLE_FORCE_COLOR": "1"})

        else:
            return self.buildErrorResult("501", "Deployment state file empty or not readable")
    else:
        return self.buildErrorResult("501", "Deployment state file missing")

@app.route('/testSyncCall/', methods = ['POST'])
def testSyncCall():
    return handler.startCommand("sleep 15","test",interaction=None,cwd=None,env=None)

@app.route('/testASyncCall/', methods = ['POST'])
def testASyncCall():
    return handler.startThread("sleep 15","test",interaction=None,cwd=None,env=None)

if __name__ == '__main__':
    app.logger.setLevel(logging.DEBUG)
    app.run(debug=False, use_reloader=False, host=config.daemon_ip, port='8505')
