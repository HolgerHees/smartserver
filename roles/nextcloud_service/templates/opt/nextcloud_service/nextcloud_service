#!/usr/bin/python3

import os
import logging
import time
import queue
import threading
import traceback

from smartserver import inotify
from smartserver.server import Server
from smartserver.command import exec2
from smartserver import nsenter

from config import config


class Handler(Server):
    def __init__(self):
        super().__init__("nextcloud_service", "0.0.0.0", "80")

        self.inotify = inotify.INotify(self._inotifyEvent)

        self.is_running = False

        self.watched_directories = {}

        self.queue = queue.Queue()
        self.queue.put(self._init)

        self.queue_thread = threading.Thread(target=self._processQueue)
        self.queue_event = threading.Event()

        self.notify_thread = threading.Thread(target=self._notifyNextcloud)
        self.notify_event = threading.Event()

        self.lock = threading.Lock()

        self.marked_directories = []

    def _init(self):
        start = time.time()
        for directory in config.watched_directories:
            self._addWatcher(directory)
        end = time.time()
        logging.info("INotify watcher initialized in {:.2f} seconds".format(end-start))

    def _addWatcher(self, directory):
        self.watched_directories[directory] = True
        self.inotify.add_watch(directory, inotify.Constants.IN_CLOSE_WRITE | inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_FROM | inotify.Constants.IN_MOVED_TO | inotify.Constants.IN_DELETE )

        for root, sub_directory_names, files in os.walk(directory):
            for _sub_directory_name in sub_directory_names:
                sub_directory = os.path.join(root, _sub_directory_name)
                self.watched_directories[sub_directory] = True
                self.inotify.add_watch(sub_directory, inotify.Constants.IN_CLOSE_WRITE | inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_FROM | inotify.Constants.IN_MOVED_TO | inotify.Constants.IN_DELETE )

    def _delWatcher(self, directory):
        del self.watched_directories[directory]
        self.inotify.rm_watch(directory)

        for root, sub_directory_names, files in os.walk(directory):
            for _sub_directory_name in sub_directory_names:
                sub_directory = os.path.join(root, _sub_directory_name)
                del self.watched_directories[sub_directory]
                self.inotify.rm_watch(sub_directory)

    def _inotifyEvent(self, event):
        #logging.info(str(event))
        self.queue.put(event)
        self.queue_event.set()

    def _notifyNextcloud(self):
        logging.info("Notify loop started")

        while self.is_running:
            now = time.time()
            next_directory = None
            with self.lock:
                if len(self.marked_directories) > 0:
                    marked_directory, marked_time = self.marked_directories[0]
                    if now - marked_time >= 2.0:
                        del self.marked_directories[0]
                        next_directory = marked_directory

            if next_directory is not None:
                args = ['files:scan', '--no-interaction', "--path=\"" + marked_directory + "\"", '--shallow', '--quiet']

                _cmd = config.enter_cmd + [ " ".join( config.notify_cmd + args ) ]

                try:
                    with nsenter.Host():
                        logging.info("RUN: " + " ".join(_cmd))
                        code, result = exec2(_cmd, isRunningCallback=self.isRunning)
                        if code != 0:
                            logging.info(result)
                            logging.info("FAILURE: " + " ".join(_cmd))

                except OSError as e:
                    logging.info(traceback.format_exc())
                    logging.info(str(e))
                    logging.info("Not able to enter php namespace. Try again in 60 seconds.")
                    self.php_container_pid = None
                    self.notify_event.wait(60)
                    self.notify_event.clear()
            else:
                next_timeout = None
                with self.lock:
                    if len(self.marked_directories) > 0:
                        _, marked_time = self.marked_directories[0]
                        next_timeout = 2.0 - ( now - marked_time )

                if next_timeout is None:
                    logging.info("Sleep notify loop")
                else:
                    logging.info("Sleep notify loop for {:.2f} seconds".format(next_timeout))

                self.notify_event.wait(next_timeout)
                self.notify_event.clear()

                if self.is_running and next_timeout is None:
                    time.sleep(2)
                    self.notify_event.clear()

        logging.info("Notify loop stopped")

    def _processQueue(self):
        logging.info("Queue loop started")

        if self.is_running:
            init = self.queue.get()
            init()

        while self.is_running:
            try:
                event = self.queue.get_nowait()

                if event.path in self.watched_directories:
                    directory = event.path
                    if event.mask & ( inotify.Constants.IN_DELETE | inotify.Constants.IN_MOVED_FROM ):
                        logging.info("Unwatch " + directory)
                        self._delWatcher(directory)
                        #logging.info("delete ok " + directory)
                        directory = os.path.dirname(directory)
                else:
                    directory = event.path if event.mask & inotify.Constants.IN_ISDIR else os.path.dirname(event.path)
                    if directory not in self.watched_directories and event.mask & ( inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_TO ):
                        logging.info("Watch " + directory)
                        self._addWatcher(directory)
                        #logging.info("add ok " + directory)

                with self.lock:
                    found = False
                    for _data in self.marked_directories:
                        if directory.startswith(_data[0]):
                            _data[1] = time.time()
                            found = True
                            break

                    if not found:
                        for _data in list(self.marked_directories):
                            if _data[0].startswith(directory):
                                self.marked_directories.remove(data)
                        self.marked_directories.append([ directory, time.time() ])

                self.notify_event.set()
            except queue.Empty:
                logging.info("Sleep queue loop")
                self.queue_event.wait()
                self.queue_event.clear()

        logging.info("Queue loop stopped")

    def isRunning(self):
        return self.is_running

    def start(self):
        self.is_running = True

        self.inotify.start()
        self.notify_thread.start()
        self.queue_thread.start()

        super().start()

    def terminate(self):
        self.is_running = False

        logging.info("Terminate inotify")
        if self.inotify.is_alive():
            self.inotify.stop()
            self.inotify.join()

        logging.info("Terminate notify_thread")
        if self.notify_thread.is_alive():
            self.notify_event.set()
            self.notify_thread.join()

        logging.info("Terminate queue_thread")
        if self.queue_thread.is_alive():
            self.queue_event.set()
            self.queue_thread.join()

        super().terminate()

    #def getStateMetrics(self):
    #    return [
    #        "ci_service_state{{job=\"ci_service\",type=\"leftover\",}} {}".format("1" if self.has_leftovers else "0")
    #    ]

handler = Handler()
handler.start()
