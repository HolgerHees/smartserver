#!/usr/bin/python3

import os
import logging
import time
import datetime
import queue
import threading
import traceback
import redis
import json

from smartserver import inotify
from smartserver.server import Server
from smartserver.command import exec2
from smartserver import nsenter

from config import config


class Handler(Server):
    def __init__(self):
        super().__init__("nextcloud_service", "0.0.0.0", "80")

        self.queue_is_running = False
        self.preview_is_running = False

        self.inotify = inotify.INotify(self._inotifyEvent)
        self.redis = redis.Redis(host=config.redis_host, port=config.redis_port, db=0)

        self.watched_directories = {}
        self.rename_events = {}

        self.queue = queue.Queue()
        self.queue.put(self._init)

        self.queue_thread = threading.Thread(target=self._processQueue)
        self.queue_event = threading.Event()

        self.preview_thread = threading.Thread(target=self._processPreview)
        self.preview_event = threading.Event()

        self.first_event = None
        self.last_event = None

    def _init(self):
        start = time.time()
        for directory in config.watched_directories:
            self._addWatcher(directory)
        end = time.time()
        logging.info("INotify watcher initialized {} directories in {:.2f} seconds".format(len(self.watched_directories.keys()), end-start))

    def _addWatcher(self, directory):
        self.watched_directories[directory] = True
        self.inotify.add_watch(directory, inotify.Constants.IN_CLOSE_WRITE | inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_FROM | inotify.Constants.IN_MOVED_TO | inotify.Constants.IN_DELETE )

        for root, sub_directory_names, files in os.walk(directory):
            for _sub_directory_name in sub_directory_names:
                sub_directory = os.path.join(root, _sub_directory_name)
                self.watched_directories[sub_directory] = True
                self.inotify.add_watch(sub_directory, inotify.Constants.IN_CLOSE_WRITE | inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_FROM | inotify.Constants.IN_MOVED_TO | inotify.Constants.IN_DELETE )

    def _delWatcher(self, directory):
        del self.watched_directories[directory]
        self.inotify.rm_watch(directory)

        for root, sub_directory_names, files in os.walk(directory):
            for _sub_directory_name in sub_directory_names:
                sub_directory = os.path.join(root, _sub_directory_name)
                del self.watched_directories[sub_directory]
                self.inotify.rm_watch(sub_directory)

    def _inotifyEvent(self, event):
        #logging.info(str(event))
        self.queue.put(event)
        self.queue_event.set()

    def _processQueue(self):
        logging.info("Queue loop started")

        try:
            if self.queue_is_running:
                init = self.queue.get()
                init()

            while self.queue_is_running:
                try:
                    event = self.queue.get_nowait()

                    if event.path in self.watched_directories:
                        directory = event.path
                        if event.mask & ( inotify.Constants.IN_DELETE | inotify.Constants.IN_MOVED_FROM ):
                            logging.info("Unwatch " + directory)
                            self._delWatcher(directory)
                            #logging.info("delete ok " + directory)
                            directory = os.path.dirname(directory)
                    else:
                        directory = event.path if event.mask & inotify.Constants.IN_ISDIR else os.path.dirname(event.path)
                        if directory not in self.watched_directories and event.mask & ( inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_TO ):
                            logging.info("Watch " + directory)
                            self._addWatcher(directory)
                            #logging.info("add ok " + directory)


                    utc_offset_sec = time.altzone if time.localtime().tm_isdst else time.timezone
                    utc_offset = datetime.timedelta(seconds=-utc_offset_sec)
                    now = datetime.datetime.now().replace(microsecond=0, tzinfo=datetime.timezone(offset=utc_offset)).isoformat()
                    #now = datetime.datetime.now().replace(microsecond=0).isoformat()

                    nextcloud_event = None
                    if event.mask & ( inotify.Constants.IN_MOVED_TO | inotify.Constants.IN_MOVED_FROM ):
                        if event.cookie not in self.rename_events:
                            self.rename_events[event.cookie] = {'event': 'move', 'from': None, 'to': None, 'time': None }

                        self.rename_events[event.cookie]['time'] = now
                        self.rename_events[event.cookie]['from' if event.mask & inotify.Constants.IN_MOVED_FROM else 'to'] = event.path

                        if self.rename_events[event.cookie]['from'] is not None and self.rename_events[event.cookie]['to'] is not None:
                            nextcloud_event = self.rename_events[event.cookie]
                            del self.rename_events[event.cookie]
                    elif event.mask & inotify.Constants.IN_DELETE:
                        nextcloud_event = {'event': 'delete', 'path': event.path, 'time': now}
                    elif event.mask & inotify.Constants.IN_CREATE:
                        nextcloud_event = {'event': 'modify', 'path': event.path, 'time': now, 'size': 0}
                    elif event.mask & inotify.Constants.IN_CLOSE_WRITE:
                        try:
                            nextcloud_event = {'event': 'modify', 'path': event.path, 'time': now, 'size': 0 if event.mask & inotify.Constants.IN_ISDIR else os.stat(event.path).st_size}
                        except FileNotFoundError:
                            # TODO maybe convert to a modify event, during follow up move event
                            # can happen when uploading *.part and rename after
                            continue
                    else:
                        logging.warn("Unexpected event: " + str(event))

                    if nextcloud_event is not None:
                        logging.info(nextcloud_event)
                        self.redis.lpush("inotify", json.dumps(nextcloud_event))

                        self.last_event = time.time()
                        if self.first_event is None:
                            self.first_event = self.last_event
                        self.preview_event.set()

                except queue.Empty:
                    #logging.info("Sleep queue loop")
                    self.queue_event.wait()
                    self.queue_event.clear()
        except Exception as e:
            self.queue_is_running = False
            raise e
        finally:
            logging.info("Queue loop stopped")

    def _processPreview(self):
        logging.info("Preview loop started")

        try:
            while self.preview_is_running:
                if self.first_event is not None:
                    now = time.time()
                    next_timeout = config.min_preview_delay - (now - self.last_event)
                    max_timeout = config.max_preview_delay - (now - self.first_event)
                    timeout = next_timeout if next_timeout < max_timeout else max_timeout
                    if timeout <= 0:
                        start = time.time()
                        with nsenter.Host():
                            code, result = exec2(config.preview_generator_cmd, isRunningCallback=self.previewIsRunning )
                        if code == 0:
                            end = time.time()
                            logging.info("Previews generated in {:.2f} seconds".format(end-start))
                            self.first_event = self.last_event = None
                            timeout = None
                        else:
                            logging.info("Not able to generate previews. Try again in 60 seconds.")
                            timeout = 60
                else:
                    timeout = None
                self.preview_event.wait(timeout)
                self.preview_event.clear()
        except Exception as e:
            self.preview_is_running = False
            raise e
        finally:
            logging.info("Preview loop stopped")

    def previewIsRunning(self):
        return self.preview_is_running

    def start(self):
        self.inotify.start()

        self.queue_is_running = True
        self.queue_thread.start()

        self.preview_is_running = True
        self.preview_thread.start()

        super().start()

    def terminate(self):
        logging.info("Terminate inotify")
        if self.inotify.is_alive():
            self.inotify.stop()
            self.inotify.join()

        logging.info("Terminate queue_thread")
        self.queue_is_running = False
        if self.queue_thread.is_alive():
            self.queue_event.set()
            self.queue_thread.join()

        logging.info("Terminate preview_thread")
        self.preview_is_running = False
        if self.preview_thread.is_alive():
            self.preview_event.set()
            self.preview_thread.join()

        super().terminate()

    def getStateMetrics(self):
        metrics = [
            "nextcloud_service_process{{job=\"preview\"}} {}".format("1" if self.preview_is_running else "0"),
            "nextcloud_service_process{{job=\"queue\"}} {}".format("1" if self.queue_is_running else "0"),
            "nextcloud_service_watches{{job=\"queue\"}} {}".format(len(self.watched_directories.keys()))
        ]
        return "{}\n".format( "\n".join(metrics) )

handler = Handler()
handler.start()
