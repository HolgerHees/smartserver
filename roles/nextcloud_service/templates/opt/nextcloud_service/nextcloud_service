#!/usr/bin/python3

import os
import logging
import time
import datetime
import queue
import threading
import traceback
import redis
import json

from smartserver import inotify
from smartserver.server import Server
from smartserver.command import exec2
from smartserver import nsenter

from config import config


class Handler(Server):
    def __init__(self):
        super().__init__("nextcloud_service", "0.0.0.0", "80")

        self.inotify = inotify.INotify(self._inotifyEvent)

        self.is_running = False

        self.watched_directories = {}

        self.queue = queue.Queue()
        self.queue.put(self._init)

        self.queue_thread = threading.Thread(target=self._processQueue)
        self.queue_event = threading.Event()

        self.rename_events = {}

        self.redis = redis.Redis(host=config.redis_host, port=config.redis_port, db=0)

    def _init(self):
        start = time.time()
        for directory in config.watched_directories:
            self._addWatcher(directory)
        end = time.time()
        logging.info("INotify watcher initialized {} directories in {:.2f} seconds".format(len(self.watched_directories.keys()), end-start))

    def _addWatcher(self, directory):
        self.watched_directories[directory] = True
        self.inotify.add_watch(directory, inotify.Constants.IN_CLOSE_WRITE | inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_FROM | inotify.Constants.IN_MOVED_TO | inotify.Constants.IN_DELETE )

        for root, sub_directory_names, files in os.walk(directory):
            for _sub_directory_name in sub_directory_names:
                sub_directory = os.path.join(root, _sub_directory_name)
                self.watched_directories[sub_directory] = True
                self.inotify.add_watch(sub_directory, inotify.Constants.IN_CLOSE_WRITE | inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_FROM | inotify.Constants.IN_MOVED_TO | inotify.Constants.IN_DELETE )

    def _delWatcher(self, directory):
        del self.watched_directories[directory]
        self.inotify.rm_watch(directory)

        for root, sub_directory_names, files in os.walk(directory):
            for _sub_directory_name in sub_directory_names:
                sub_directory = os.path.join(root, _sub_directory_name)
                del self.watched_directories[sub_directory]
                self.inotify.rm_watch(sub_directory)

    def _inotifyEvent(self, event):
        #logging.info(str(event))
        self.queue.put(event)
        self.queue_event.set()

    def _processQueue(self):
        logging.info("Queue loop started")

        try:
            if self.is_running:
                init = self.queue.get()
                init()

            while self.is_running:
                try:
                    event = self.queue.get_nowait()

                    if event.path in self.watched_directories:
                        directory = event.path
                        if event.mask & ( inotify.Constants.IN_DELETE | inotify.Constants.IN_MOVED_FROM ):
                            logging.info("Unwatch " + directory)
                            self._delWatcher(directory)
                            #logging.info("delete ok " + directory)
                            directory = os.path.dirname(directory)
                    else:
                        directory = event.path if event.mask & inotify.Constants.IN_ISDIR else os.path.dirname(event.path)
                        if directory not in self.watched_directories and event.mask & ( inotify.Constants.IN_CREATE | inotify.Constants.IN_MOVED_TO ):
                            logging.info("Watch " + directory)
                            self._addWatcher(directory)
                            #logging.info("add ok " + directory)


                    utc_offset_sec = time.altzone if time.localtime().tm_isdst else time.timezone
                    utc_offset = datetime.timedelta(seconds=-utc_offset_sec)
                    now = datetime.datetime.now().replace(microsecond=0, tzinfo=datetime.timezone(offset=utc_offset)).isoformat()
                    #now = datetime.datetime.now().replace(microsecond=0).isoformat()

                    nextcloud_event = None
                    if event.mask & ( inotify.Constants.IN_MOVED_TO | inotify.Constants.IN_MOVED_FROM ):
                        if event.cookie not in self.rename_events:
                            self.rename_events[event.cookie] = {'event': 'move', 'from': None, 'to': None, 'time': None }

                        self.rename_events[event.cookie]['time'] = now
                        self.rename_events[event.cookie]['from' if event.mask & inotify.Constants.IN_MOVED_FROM else 'to'] = event.path

                        if self.rename_events[event.cookie]['from'] is not None and self.rename_events[event.cookie]['to'] is not None:
                            nextcloud_event = self.rename_events[event.cookie]
                            del self.rename_events[event.cookie]
                    elif event.mask & inotify.Constants.IN_DELETE:
                        nextcloud_event = {'event': 'delete', 'path': event.path, 'time': now}
                    elif event.mask & inotify.Constants.IN_CREATE:
                        nextcloud_event = {'event': 'modify', 'path': event.path, 'time': now, 'size': 0}
                    elif event.mask & inotify.Constants.IN_CLOSE_WRITE:
                        try:
                            nextcloud_event = {'event': 'modify', 'path': event.path, 'time': now, 'size': 0 if event.mask & inotify.Constants.IN_ISDIR else os.stat(event.path).st_size}
                        except FileNotFoundError:
                            # TODO maybe convert to a modify event, during follow up move event
                            # can happen when uploading *.part and rename after
                            continue
                    else:
                        logging.warn("Unexpected event: " + str(event))

                    if nextcloud_event is not None:
                        logging.info(nextcloud_event)
                        self.redis.lpush("inotify", json.dumps(nextcloud_event))

                except queue.Empty:
                    #logging.info("Sleep queue loop")
                    self.queue_event.wait()
                    self.queue_event.clear()
        except Exception as e:
            self.is_running = False
            raise e
        finally:
            logging.info("Queue loop stopped")

    def isRunning(self):
        return self.is_running

    def start(self):
        self.is_running = True

        self.inotify.start()
        self.queue_thread.start()

        super().start()

    def terminate(self):
        self.is_running = False

        logging.info("Terminate inotify")
        if self.inotify.is_alive():
            self.inotify.stop()
            self.inotify.join()

        logging.info("Terminate queue_thread")
        if self.queue_thread.is_alive():
            self.queue_event.set()
            self.queue_thread.join()

        super().terminate()

    def getStateMetrics(self):
        metrics = [
            "nextcloud_service_process{{job=\"queue\"}} {}".format("1" if self.is_running else "0"),
            "nextcloud_service_watches{{job=\"queue\"}} {}".format(len(self.watched_directories.keys()))
        ]
        return "{}\n".format( "\n".join(metrics) )

handler = Handler()
handler.start()
